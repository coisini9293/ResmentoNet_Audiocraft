我先快速看了你给的 `musicgen_app.py` 和你的整体设想。接下来我会：

- 评估可行性、给出推荐的系统架构与落地做法
- 明确 4 个 Agent 的职责与交互流
- 给出 MySQL 表设计建议、Streamlit 连接方式、Agent 调 MySQL 的正确姿势
- 提供最小可用代码骨架，让你可以直接串起来

如果你同意，我会在后续迭代里把工具函数和 Agent/Graph 的代码骨架补齐到你的仓库中。

### 可行性与整体架构建议

- 可行性：整体设想完全可行。建议用“有监督的多 Agent 编排”而不是传统 ReAct Agent 串行，以保证强时序与确定性（尤其是 GPU 生成耗时、状态同步）。
- 编排推荐：
  - 用 LangGraph（或 LangChain Expression Language + Router）构建一个线性＋条件分支的图：Face → LLM 初稿（Agent3）→ 个性化（Agent4）→ 生成（Agent2）。
  - Agent1/2 均包装为“工具 Tool”（函数调用），Agent3/4 作为“LLM 节点”（Prompt 模板 + 上下文）。
  - 所有持久化/素材路径/评分等均通过 MySQL 落库，文件落本地（或对象存储），DB 存路径和元数据。
- 模块分层：
  - UI：`web_app`（Streamlit）统一入口。不要在 UI 层直接跑 Gradio；将 `musicgen_app.py` 里核心生成逻辑抽成可被调用的函数，UI 层只调工具。
  - Service/Tools：`tools/face_tool.py`、`tools/musicgen_tool.py`、`tools/mysql_repo.py`。
  - Orchestration：`agents/graph.py` 管理 4 个节点串联。
  - Data 层：`mysql`（SQLAlchemy） + 本地 `data/` 资源目录。

### 4 个 Agent 的职责与数据流

- Agent1（情绪识别）：
  - 输入：图片/视频路径
  - 输出：`{emotion: sad/disgust/angry/fear, confidence: 0~1, extra: {...}}`
  - 作为 Tool 实现（Python 函数），由 Graph 的第一个节点调用
- Agent3（初稿描述）：
  - 输入：Agent1 的输出（情绪、置信度、可选时间段/关键帧）
  - 输出：英文音乐描述（短 Prompt，结构化字段如 bpm/情绪/器乐）
  - 作为 LLM 节点（Prompt 模板 + 少样例），避免跑偏
- Agent4（个性化扩充）：
  - 输入：Agent3 的初稿 + MySQL 用户画像/偏好 + 最近行为（评分/投票/最近生成历史）
  - 输出：完整 MusicGen Prompt（风格、器乐、结构、节奏、混音、负面提示等），以及生成参数建议（duration, top_k, top_p, temperature, cfg_coef, 模型名）
- Agent2（文生音乐）：
  - 输入：Agent4 完整 Prompt + 可选旋律参考（若用户上传）+ 生成参数
  - 输出：音频文件路径（以及可选视频波形路径）
  - 作为 Tool 实现（Python 函数），内部复用你已有的 MusicGen 代码

### 与现有 `musicgen_app.py` 的整合

你当前文件是 Gradio 页面 + 逻辑混在一起。两种做法：

- A. 直接“函数化调用”当前脚本的核心函数：
  - 复用 `predict_full(...)` 作为工具调用（它返回视频与 wav 路径），Streamlit/Agent2 侧直接 import 调用。
  - 注意：`predict_full` 使用了 `gr.Progress()`，但只作为回调进度对象，不影响离线调用。可传默认值。
  - 优点：最快打通。缺点：仍依赖 Gradio，和 UI 解耦不彻底。
- B. 抽取“纯后端生成函数”：
  - 从 `musicgen_app.py` 中抽出“加载模型”和“生成音频”的核心，做成 `tools/musicgen_tool.py`，移除 UI 依赖，避免 `gradio` 强耦合。
  - 优点：无 UI 依赖、轻量、易测。缺点：需要轻度重构。

建议先用 A 快速打通；后续用 B 做干净重构。

### MySQL：表设计（建议最小集）

你可先用这些表开始，后续再补字段：

- `users`
  - `id` PK, `username` UNIQUE, `password_hash`, `created_at`
- `user_profiles`
  - `user_id` FK users, `age`, `gender`, `locale`, `notes`
- `user_preferences`
  - `user_id` FK, `fav_genres` JSON, `fav_instruments` JSON, `bpm_min`, `bpm_max`, `negative_prompts` TEXT
- `sessions`
  - `id` PK, `user_id` FK, `started_at`, `source`(web/api)
- `assets`
  - `id` PK, `session_id` FK, `type` ENUM('image','video','melody','wav','video_waveform'), `path`, `mime`, `md5`, `created_at`
- `emotions`
  - `id` PK, `session_id` FK, `emotion` ENUM('sad','disgust','angry','fear'), `confidence` FLOAT, `frame_ts` NULLABLE, `extra` JSON, `created_at`
- `generations`
  - `id` PK, `session_id` FK, `prompt_initial` TEXT, `prompt_personalized` TEXT, `model` VARCHAR, `params_json` JSON, `duration_sec` INT, `wav_path` TEXT, `video_path` TEXT, `created_at`
- `feedbacks`
  - `id` PK, `generation_id` FK, `user_id` FK, `score` TINYINT(0-5), `vote` ENUM('up','down') NULL, `comment` TEXT, `created_at`
- `events`
  - `id` PK, `session_id` FK, `agent` VARCHAR, `event_type` VARCHAR, `payload_json` JSON, `ts` DATETIME

说明：

- 大型文件（wav、视频）放 `data/` 目录（或对象存储），MySQL 存“相对路径 + 元数据”。避免把二进制塞 DB。
- 你的 `FileCleaner` 思路可以迁移到后台清理任务，但生产建议保留完整可追溯（清理策略加保留期）。

### Agent 是否可以调用 MySQL？

可以，但推荐“Agent 只调用 Tool，Tool 访问 MySQL”。也就是：

- Agent 通过 LangChain Tool（函数）调用一个 Repository 方法，比如 `get_user_preferences(user_id)`、`save_generation(...)`。
- 好处：Agent 保持“无状态决策”，数据访问统一封装，便于测试和替换。

最小工具示例（Repository + Tool）：

```python
# tools/mysql_repo.py
import sqlalchemy as sa
from sqlalchemy import text

class MySQLRepository:
    def __init__(self, engine):
        self.engine = engine

    def get_user_preferences(self, user_id:int) -> dict:
        with self.engine.begin() as conn:
            row = conn.execute(
                text("SELECT fav_genres, fav_instruments, bpm_min, bpm_max, negative_prompts FROM user_preferences WHERE user_id=:uid"),
                {"uid": user_id}
            ).mappings().first()
        return dict(row) if row else {}

    def save_generation(self, session_id:int, prompt_initial:str, prompt_personalized:str, model:str, params_json:dict, wav_path:str, video_path:str|None, duration:int):
        with self.engine.begin() as conn:
            conn.execute(text("""
                INSERT INTO generations (session_id, prompt_initial, prompt_personalized, model, params_json, wav_path, video_path, duration_sec, created_at)
                VALUES (:sid, :pi, :pp, :m, :pj, :wp, :vp, :dur, NOW())
            """), dict(sid=session_id, pi=prompt_initial, pp=prompt_personalized, m=model, pj=params_json, wp=wav_path, vp=video_path, dur=duration))
```

注册成 LangChain Tool：

```python
# tools/db_tools.py
from langchain.tools import tool

repo = ...  # 注入 MySQLRepository 实例

@tool("get_user_preferences")
def get_user_preferences_tool(user_id:str) -> str:
    return repo.get_user_preferences(int(user_id))  # 返回 JSON 可被 LLM 解析
```

### Streamlit 如何连接到 MySQL

推荐 SQLAlchemy + PyMySQL 驱动，凭据放 `streamlit.secrets.toml`：

- `.streamlit/secrets.toml`

```
db_user = "user"
db_password = "pass"
db_host = "127.0.0.1"
db_name = "music_app"
```

- Streamlit 端最小示例：

```python
# web_app/db.py
import streamlit as st
import sqlalchemy as sa

@st.cache_resource
def get_engine():
    url = sa.engine.URL.create(
        "mysql+pymysql",
        username=st.secrets["db_user"],
        password=st.secrets["db_password"],
        host=st.secrets["db_host"],
        port=3306,
        database=st.secrets["db_name"],
    )
    return sa.create_engine(url, pool_pre_ping=True, pool_recycle=3600)

engine = get_engine()
```

查询与写入：

```python
# web_app/pages/admin.py
import pandas as pd
from sqlalchemy import text
from .db import engine

def load_generations():
    with engine.begin() as conn:
        rows = conn.execute(text("SELECT id, session_id, model, duration_sec, created_at FROM generations ORDER BY id DESC LIMIT 100")).mappings().all()
    return pd.DataFrame(rows)

df = load_generations()
st.dataframe(df)
```

### MySQL 的数据在哪看、怎么查看

- 图形客户端：MySQL Workbench、DBeaver、TablePlus（推荐），连上你的 MySQL 服务即可浏览表与数据。
- 命令行：
  - 登录：`mysql -h 127.0.0.1 -u user -p`
  - 列库：`SHOW DATABASES;`；用库：`USE music_app;`
  - 查数：`SELECT * FROM generations ORDER BY id DESC LIMIT 20;`
- 页面查看：你可以做一个 `Streamlit` 的“管理/运营”子页，表格分页＋搜索。

### Agent2：对接 MusicGen 的最小落地路径

快速可用（复用你现有的函数，0 重构）：

```python
# tools/musicgen_tool.py
from audiocraft_main.audiocraft_main.demos.musicgen_app import predict_full

def generate_music_files(
    model:str,
    model_path:str,
    decoder:str,
    text:str,
    melody,           # (sr, np.ndarray) 或 None
    duration:int,
    topk:int,
    topp:float,
    temperature:float,
    cfg_coef:float
):
    video, wav, video_mbd, wav_mbd = predict_full(
        model, model_path, decoder, text, melody, duration, topk, topp, temperature, cfg_coef
    )
    # 返回 wav 路径优先，其余由上层决定是否展示
    return dict(wav=wav, video=video, wav_mbd=wav_mbd, video_mbd=video_mbd)
```

- 说明：`predict_full` 默认会写出 wav 与视频文件并返回路径。Agent2 拿到路径后即可落库。
- 后续重构方向：把 `predict_full` 拆成“纯生成（不依赖 gradio）”的函数，规避 `gradio` 依赖和全局状态。

### Agent1：面部识别 Tool

- 用现有 `face` 模块暴露一个纯函数：输入文件路径，输出 `{emotion, confidence, ...}`。保证固定枚举与置信度。
- 支持视频时，取关键帧或按固定 fps 采样，输出“主导情绪 + 时间段”。

伪代码：

```python
# tools/face_tool.py
from langchain.tools import tool

@tool("detect_emotion")
def detect_emotion_tool(media_path:str) -> dict:
    # 调用你的 face 模块
    result = run_face_inference(media_path)
    # 统一输出结构
    return {"emotion": result.emotion, "confidence": result.confidence, "segments": result.segments}
```

### Agent3 与 Agent4：LLM 模板与记忆融合

- Agent3（初稿）提示词要“够结构化”：
  - 输入：`emotion` 与可选 `segments`
  - 输出：`{style, mood, bpm, instruments, structure, description}`，注意用英文词汇以适配 MusicGen
- Agent4（个性化）：
  - 读取 `user_preferences` 并融合（比如限制 bpm 范围、加入用户喜欢的 `genres/instruments`、追加 `negative_prompts`），同时保留 Agent3 的核心意图。
  - 最终拼接为可投喂 MusicGen 的“富描述 Prompt + 生成参数建议”。

### Streamlit：登录与会话

- 登录态：`st.session_state["user_id"]`，登录成功后持久化。
- 每次生成音乐前创建 `session`（一条），把 Agent1 的情绪、Agent3/4 的 Prompt、Agent2 的结果一并落库。
- 用户评分：对 `generations.id` 做评分/投票写入 `feedbacks`。

### 关键工程点

- GPU/性能：模型只加载一次并复用；串行队列化调用以避免 OOM；必要时单独起一个“生成服务”进程，Streamlit/Agent 通过 RPC/队列调用。
- 资源存储：`data/{user_id}/{session_id}/...` 分层，文件名加 md5；DB 存相对路径。
- 审计与可重跑：落库 `params_json`（top_k, top_p, temperature, cfg_coef, decoder, model）。
- 隐私与合规：用户上传素材和生成音频的保留期与删除入口，日志可匿名化。

### 你现在可以直接做的最小步骤

- 在 `web_app` 里接 MySQL（用上面 secrets + engine 代码）
- 把 `predict_full` 包成 `tools/musicgen_tool.py` 函数（如上）
- 把 `face` 推理封装为 `tools/face_tool.py`
- 写一个极简的 LangChain graph：顺序执行 4 步，最后把结果落库并在 Streamlit 展示 wav

如果你愿意，我可以把这些最小骨架文件直接加到你的项目里，并补一页 `Streamlit` Demo 页面来串起来。

- 我已梳理你的架构与目标，给出多 Agent 编排、数据表设计、以及 Streamlit/MySQL/Agent 调用的最小实现路径。
- 下一步我可以直接在 `tools/` 与 `web_app/` 下新增最小代码骨架（Agent/Tools/Repo/页面），快速把第一条“从图片→情绪→个性化 Prompt→音乐→评分”的闭环跑通。

prompt：

A melancholic lofi piano track at 70 BPM in A minor, featuring soft piano and warm pads, subtle vinyl hiss, gentle percussion. Arrangement: 0–8s sparse intro, 8–22s main theme with light bass, 22–30s soft breakdown. Mix: warm, wide, smooth highs, gentle compression. Avoid: vocals, heavy drums, harsh leads.
﻿
A dark industrial track at 110 BPM with metallic percussion, distorted synths, dissonant textures, gritty bass. Arrangement: 0–6s noisy intro, 6–22s driving groove, 22–30s tension rise. Mix: cold, narrow mids, saturated edges, controlled low end. Avoid: acoustic guitars, cheerful chords, vocals.
﻿
An aggressive heavy rock/metal track at 150 BPM with distorted rhythm guitars, tight bass, punchy drums, occasional leads. Arrangement: 0–6s short intro, 6–22s main riff, 22–30s intensified chorus with double kicks. Mix: punchy, tight, bright presence. Avoid: pads, vocals, orchestral strings.
﻿
A cinematic suspense cue at 90 BPM with low strings, pulsing bass, drones, sparse hits, airy textures. Arrangement: 0–10s tense build, 10–24s pulse with evolving drones, 24–30s riser and sting. Mix: dark, wide, deep lows, minimal highs. Avoid: melody vocals, upbeat drums, major chords.

A cheerful, upbeat pop/EDM track at 124 BPM in C major, featuring acoustic guitar strums, bright synth lead, plucky arps, punchy kick and snappy claps, warm bass. Arrangement: 0–6s catchy intro with a short riser, 6–20s main groove with chord stabs and sidechained pads, 20–30s lift/mini-chorus adding tambourine and extra layers. Mix: bright and punchy, wide stereo, clean low end, subtle sidechain compression, minimal reverb on drums. Use case: feel‑good vlog and lifestyle content. Avoid: vocals, harsh distortion, heavy metal guitars, dark drones. Overall: energetic, positive, danceable.

A smooth contemporary R&B instrumental at 92 BPM in F minor, featuring warm Rhodes electric piano chords, clean jazz guitar licks, silky synth lead, deep sub-bass, laid-back swing drums with soft snares and crisp hats. Arrangement: 0–6s mellow intro, 6–20s main groove with subtle counter-melodies, 20–30s lift with extra chord voicings and light percussion. Mix: warm and intimate, wide stereo, gentle tape saturation, smooth highs, tight low end, light sidechain. Use case: late-night chill and romantic vibes. Avoid: vocals, aggressive distortion, EDM supersaws, orchestral strings.

A 2000s Mandopop R&B ballad at 94 BPM in A minor, featuring warm Rhodes electric piano chords, clean funk-influenced electric guitar licks, silky synth pads, deep sub-bass, and tight, syncopated drum groove (punchy kick, crisp snare, bright hats). Arrangement: 0–6s intimate intro (keys + sparse guitar), 6–20s verse groove with tasteful guitar fills and subtle chord extensions, 20–30s hook with wider pads and a catchy counter-melody. Mix: warm and glossy, wide stereo, gentle tape saturation, smooth highs, tight low end, light sidechain. Use case: contemporary Mandopop R&B vibe. Avoid: heavy rock distortion, EDM supersaws, orchestral strings, rap vocals.
